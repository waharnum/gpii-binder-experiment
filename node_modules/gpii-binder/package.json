{
  "_args": [
    [
      "gpii-binder@git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "/Users/aharnum/work/gpii-binder-experiment"
    ]
  ],
  "_from": "git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
  "_id": "gpii-binder@1.0.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/gpii-binder",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/GPII/gpii-binder/f4bd55bace97c5eb8fc67ed108cef46f3214aa15/package.json",
      "gitUrl": "git://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "httpsUrl": "git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "shortcut": "github:GPII/gpii-binder#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "ssh": "git@github.com:GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "sshUrl": "git+ssh://git@github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
      "type": "github"
    },
    "name": "gpii-binder",
    "raw": "gpii-binder@git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
    "rawSpec": "git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
    "scope": null,
    "spec": "git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
  "_shasum": "7882cfee3c224f9630162995e122c0be6938d119",
  "_shrinkwrap": null,
  "_spec": "gpii-binder@git+https://github.com/GPII/gpii-binder.git#f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
  "_where": "/Users/aharnum/work/gpii-binder-experiment",
  "bugs": {
    "url": "https://github.com/GPII/gpii-binder/issues"
  },
  "dependencies": {
    "infusion": "2.0.0-dev.20160519T222603Z.754d2c6"
  },
  "description": "This package provides a mechanism for binding [Fluid view component](http://docs.fluidproject.org/infusion/development/tutorial-gettingStartedWithInfusion/ViewComponents.html) model variables to DOM elements using [selectors](http://docs.fluidproject.org/infusion/development/tutorial-gettingStartedWithInfusion/ViewComponents.html#selectors).",
  "devDependencies": {
    "eslint": "2.11.1",
    "grunt": "1.0.1",
    "grunt-eslint": "18.1.0",
    "grunt-jsonlint": "1.0.4",
    "istanbul": "0.4.4",
    "node-jqunit": "~1.1.3",
    "qunitjs": "1.12.0",
    "rimraf": "^2.5.1",
    "shelljs": "0.7.0",
    "testem": "1.9.1"
  },
  "gitHead": "f4bd55bace97c5eb8fc67ed108cef46f3214aa15",
  "homepage": "https://github.com/GPII/gpii-binder#readme",
  "license": "BSD-3-Clause",
  "name": "gpii-binder",
  "optionalDependencies": {},
  "private": false,
  "readme": "# `gpii-binder`\n\nThis package provides a mechanism for binding [Fluid view component](http://docs.fluidproject.org/infusion/development/tutorial-gettingStartedWithInfusion/ViewComponents.html) model variables to DOM elements using [selectors](http://docs.fluidproject.org/infusion/development/tutorial-gettingStartedWithInfusion/ViewComponents.html#selectors).\n\nYou can bind to any DOM element whose value can be read and set using\n[`fluid.value`](http://docs.fluidproject.org/infusion/development/ViewAPI.html#fluid-value-nodein-newvalue-), but the\nprimary (and tested) use case is binding model variables to form elements, specifically:\n\n* text `<input>` fields\n* radio `<input>` fields\n* checkbox `<input>` fields\n* `<textarea>` fields\n* `<select>` fields\n\nOnce you run `gpii.binder.applyBinding(component)` (see \"Static Functions\" below), a binding is created\nbetween any selectors and model variables referenced in`options.binding` (see \"Supported options\" for the format).\n\nOnce a binding exists, changes to a bound model sent using [the change applier](http://docs.fluidproject.org/infusion/development/ChangeApplier.html)\nare used to update the DOM element's value.\n\nThe binding is bidirectional.  Change events to a bound DOM element's value are also relayed to the associated model\nvariable.  Note that change events are not generated when you directly set the element's value, but only when you have\nupdated the value using browser events *and* change focus.  For more details, see the\n[jQuery documentation for the change event](https://api.jquery.com/change/).\n\n\n# Supported options\n\nThe `gpii.binder.applyBinding` function provided by this package can only do its work if you have the\nfollowing options defined:\n\n| Option             | Type     | Description |\n| ------------------ | -------- | ----------- |\n| `selectors` | `{Object}` | You must define one or more [selectors](http://docs.fluidproject.org/infusion/development/tutorial-gettingStartedWithInfusion/ViewComponents.html#selectors) that can be used in a binding. |\n| `bindings` | `{Object}` | Defines the relationship between selectors and model variables.  The full notation for this option is outlined below. |\n\n## Long notation\n\nThere are two ways of specifying bindings.  The \"long form\" has named keys (as in the first example above) and\nsupports the following options:\n\n* selector: A valid selector for your component.  Must be able to be resolved using `that.locate(selector)`\n* path: A valid path for the model variable whose value will be watched.  Must be able to be resolved using `fluid.get(that.model, path)`.\n* rules.domToModel: Model transformation rules that are applied to a DOM (element) value before it is relayed to the model.\n* rules.modelToDom: Model transformation rules that are applied to a model value before it is relayed to the DOM (element).\n\nThe \"long form\" looks like:\n\n    bindings: {\n        \"<key>\": {\n            selector: \"<selector1>\",\n            path:     \"<path1>\"\n        }\n    }\n\nThe following is an example of how model transformation rules are used in binding definitions:\n\n    bindings: {\n        \"myKey\": {\n            selector: \"mySelector\",\n            path:     \"myPath\",\n            rules: {\n                domToModel: {\n                    \"\": {\n                        transform: {\n                            type: \"fluid.transforms.numberToString\",\n                            inputPath: \"\"\n                        }\n                    }\n                },\n                modelToDom: {\n                    \"\": {\n                        transform: {\n                            type: \"fluid.transforms.stringToNumber\",\n                            inputPath: \"\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n\nIn the above example:\n\n1. A model change to the `myPath` variable will be transformed from a number to a string before the DOM element is updated.\n2. A form element change will be transformed to a number before it is applied to the model.\n\nIf you do not supply any rules, be aware that non-string values will be converted to strings using their `toString` \nmethod.  For objects, this results in the form values being set to the literal string `[Object object]`.\n\n## Short notation\n\nThe \"short form\" uses the selector as the key, and the path as a string value (as in the second example above).\n\n    bindings: {\n        \"<selector2>\": \"<path2>\"\n    }\n\n\n## Combining the two notations\n\nYou can use both forms together, as in:\n\n    bindings: {\n        \"<key>\": {\n            selector: \"<selector1>\",\n            path:     \"<path1>\"\n        },\n        \"<selector2>\": \"<path2>\"\n    }\n\n\n\n# Static Functions\n\n## `gpii.binder.applyBinding(component)`\n* `component` `{Object}` - A fluid `viewComponent` with both `selectors` and `bindings` options defined (see above).\n* Returns: Nothing.\n\nYou must explicitly invoke this function to create bindings.  Generally you wil do this from a\n[listener definition](http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html#registering-a-listener-to-an-event).\nFor example, if all required markup already exists on startup, you can simply bind to the \"onCreate\" event, as in:\n\n    listeners: {\n        \"onCreate.applyBindings\": {\n            \"funcName\": \"gpii.binder.applyBinding\",\n            \"args\":     \"{that}\"\n        }\n    }\n\nThe `gpii.binder.bindOnCreate` grade included with this package will do this for you.\n\n### Bindings and dynamic markup\n\nIf your component generates or regenerates markup, you will need to call `gpii.binder.applyBinding(component)`\nwhenever it changes.  The `gpii.binder.bindOnDomChange` grade included in this package will reapply the bindings\nwhenever an `onDomChange` event is fired.\n\n# Tests\n\nTo run the tests in this package, run `npm test`.  In addition to the normal test output, an\n[Istanbul](https://github.com/gotwarlost/istanbul) test coverage report will be saved to `coverage/lcov-report/index.html`.",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GPII/gpii-binder.git"
  },
  "scripts": {
    "test": "node node_modules/testem/testem.js ci --skip PhantomJS,Chromium,Safari"
  },
  "version": "1.0.0"
}
